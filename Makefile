top="$(CURDIR)"/

CFLAGS+=
LDFLAGS+=
CC=gcc
C_COMPILE=$(CC) $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
C_DEPENDENCIES=-Wp,-MD,$(DEPDIR)$(*F).P
C_LINK=$(CC) $(CFLAGS) $(LDFLAGS) -L.
AR=ar
AR_CMD=$(AR) cr
VERSION=1.0

DISTDIR=$(top)$(shell basename $(top))-$(VERSION)
DEPDIR=.deps/

# Target name of dependency file generated by GCC, is just xxx.o
# So, we need post processing to handle it properly.
# To avoid this overhead... we don't use output directory.!
OUTDIR=

TARGET=$(OUTDIR)y
LIB=lib$(TARGET).a
PUB_HEADER=ycrc.h ydef.h ylist.h ylistl.h yqueue.h ystack.h ytree.h ytreel.h ytrie.h yhash.h ylib.h


INCLUDES=
SOURCES=crc.c  tree.c trie.c hash.c
TEST_SOURCES=test_main.c test_list.c test_queue.c test_stack.c test_tree.c test_hash.c
OBJ=$(subst .c,.o, $(addprefix $(OUTDIR),$(SOURCES)))
TEST_OBJ=$(subst .c,.o, $(addprefix $(OUTDIR),$(TEST_SOURCES)))
DEP_FILES=$(subst .c,.P, $(addprefix $(DEPDIR),$(SOURCES)))
DEP_FILES+=$(subst .c,.P, $(addprefix $(DEPDIR),$(TEST_SOURCES)))


debug: $(TARGET)

release: $(LIB)

DEPS_MAGIC := $(shell mkdir $(DEPDIR) > /dev/null 2>&1 || :)
OUTS_MAGIC := $(shell mkdir $(OUTDIR) > /dev/null 2>&1 || :)

# simply ignore file which doesn't exist. (At first these files don't exist..)
-include $(DEP_FILES)

$(OUTDIR)%.o: %.c
	@echo '$(C_COMPILE) -o $@ -c $<'; \
	$(C_COMPILE) $(C_DEPENDENCIES) -o $@ -c $<

$(LIB): $(OBJ)
	@echo '$(AR_CMD) $@ $^'; \
	$(AR_CMD) $@ $^
	cp $@ ../libs/
	chmod 0644 $@
	cp $(PUB_HEADER) ../includes/

$(TARGET): $(OBJ) $(TEST_OBJ)
	@echo '$(C_LINK) -o $@ $^'; \
	$(C_LINK) -o  $@ $^


tags:


clean:
	rm -f *.mod *.o *.obj .lo $(TARGET) $(LIB)
	rm -rf $(DEPDIR)
	rm -rf $(OUTDIR)

.PHONY: dist

dist:
	rm -rf $(DISTDIR)
	mkdir $(DISTDIR)
	cp $(SOURCES) $(DISTDIR)
	tar -cvzf $(DISTDIR).tar.gz $(DISTDIR)
	rm -rf $(DISTDIR)

# End of Makefile
